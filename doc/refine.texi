\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename refine.info
@settitle Refine Library Manual
@c %**end of header

@c @copying
@c The refine library overview, version 1.0.
@c @end copying

@titlepage
@title Refine Library Manual

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@c @insertcopying
The refine library overview, version 1.0.
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top
@top Refine Library Manual

@c @insertcopying
@end ifnottex

@menu
* Introduction  :: Short description.
* Overview      :: Basic architecture
* Base Objects  :: Base objects for grid.
* Grid Object   :: The main object: grid.
* Grid Mix-ins  :: Additional methods for grid object
* Running FUN3D :: HOWTO run FUN3D with refine
* Support       :: Performing support tasks
* Add Me        :: Documentation Wish List.
* Index         :: Complete index.
@end menu

@node Introduction
@chapter Introduction
@cindex introduction

This is a copy of refine/README file from the distribution.

Refine is a 3D tetrahedral grid adaptation framework. It is
implemented with an object-oriented flavor in the C language.  Most
functionality is wrapped into Ruby scripting language extensions
@url{http://www.ruby-lang.org/} for use in test first programming and unit
testing. See the README.EXT file in the Ruby distribution for details
on ruby extensions.
 
The refine library can be called by FUN3D @url{http://fun3d.larc.nasa.gov/}
to perform adaptation with a parallel execution scheme.
 
CAD geometry access is facilitated with the NASA Langley Geometry
Laboratory SDK @url{http://geolab.larc.nasa.gov/}, which assess CAD
information with the CAPRI API
@url{http://raphael.mit.edu/capri/docs.html}.

MesherX is an advancing layer mixed-element mesher that interacts
with the SDK to rebuild the inviscid portions of the grid. 

@node Overview
@chapter Overview
@cindex overview

@section Conventions
@cindex conventions

The term `object' will be used loosely in this manual. An object
defined is a pointer to a C structure with its associated methods that
are generally bundled into a C header and source file. I got this idea
from the way that the Ruby interpreture is written in C.

NOTE: although the C struct of the objects is often exposed for macro
access to increase efficiency by reducing the number of function
calls, please resist the desire to access struct elements directly;
use the available methods or macros.

A pointer to a C struct is passed as the first argument to `object'
methods. These methods generally return @code{NULL} or @code{EMPTY
(-1)} when they fail. They return a C struct pointer (often the first
argument) or the result if they are successful.

@section Architecture
@cindex architecture

The refine library is composed of base objects, the grid object, grid
mix-ins, child objects, and others. Items denoted with (M) or (R) are
only used with MesherX (M) or the stand-alone sequential refine
executable (R).

@heading Base objects:
@enumerate
@item adj - element node adjacency
@item queue - transaction queue for parallel connectivity modifications
@item sort - list sorting and searching routines
@item line - stores arrays of nodes (advancing layer growth curves)
@item near - near tree for finding nearby things (M)
@item intersect - computes if elements intersect (M)
@end enumerate

@heading Grid Object:
@enumerate
@item grid - stores the majority of grid data and provides low-level methods.
@end enumerate

@heading Grid Mix-ins
@enumerate
@item gridmath - basic vector and matrix math routines
@item gridmetric - computes element metrics (volume, aspect ratio)
@item gridswap - edge and face swapping routines
@item gridcad - node projection and node smoothing for improved element quality
@item gridgeom - parallel GeoSDK/CAPRI restart routines (R)
@item gridinsert - inserts and removes nodes into grid
@item gridmpi - parallel grid adaptation helper
@item gridfortran - fortran bindings for linking to FUN3D
@item gridfiller - sequential GeoSDK/CAPRI restart routines (M,R)
@end enumerate

@heading Grid Children (inherits from grid object)
@enumerate
@item gridmove - grid movement by linear elasticity or springs 
@item layer - advancing layer mesher object (M)
@end enumerate

@heading Others
@enumerate
@item refine_main - stand-alone refine main. (R)
@item MesherX - MesherX main. (M)
@item mesherx - MesherX driver routines. (M)
@item mesherxInit - Build layer object from GeoSDK/CAPRI restart. (M)
@item mesherxRebuild - Inviscid mesh rebuild routines for advancing layer meshes. (M)
@end enumerate

@section Unit Testing
@cindex test, unit

Most of the objects listed in the previous ``Architecture'' section is
composed of four files:

@enumerate
@item @code{anobjectMT.rb} - Ruby unit test script, This contains the object's Mobility Test (MT).
@item @code{anobject_ruby.c} - Ruby wrapper code to allow Ruby to load the object.
@item @code{anobject.h} - C header file
@item @code{anobject.c} - C source file.
@end enumerate

When the @code{anobjectMT.rb} script is evoked, it first calls
@code{RubyExtensionBuilder.rb}. The @code{RubyExtensionBuilder.rb}
script handles any dependencies by making any ruby extensions that the
@code{anobjectMT.rb} script requires to run. Each object is created
with the @code{makeRubyExtension.rb} script. The
@code{makeRubyExtension.rb} script C creates a subdirectory named
AnObject. Inside this directory the standard Ruby @code{mkmf.rb}
module is evoked to create a makefile, which is used to create a
shared object. The shared object is loaded into the
@code{anobjectMT.rb} script with
@verbatim
  require 'AnObject/AnObject'
@end verbatim

Any other objects that are required by AnObject will also need to be
added to the top of @code{AnObject.rb}. If the object is a mixin, you
will need to add is methods to a base object after it has been
require'd. This following example from @code{gridmetricMT.rb} adds the
gridmetic mix-in methods to the grid object.

@verbatim
class Grid
 include GridMetric
end
@end verbatim

@node Base Objects
@chapter Base Objects
@cindex object, base

The most important refine library base objects are adj, queue, and sort.

@section Adj
@cindex adj

The adj object stores the adjacency of items (elements) to nodes. It
has the ability to be dynamically resized and grown. It is initialized
@code{adjCreate} with the max node count, max adjacency, and a chunk
size for growing more adjacencies.

A new item adjacency is added with @code{adjRegister} method by
specifying a node and integer item index. It can also be removed with
@code{adjRemove}. A node's item count is @code{adjDegree}. The
presence of a item attached to a node is tested with @code{adjExists}.

Use a @code{AdjIterator} to loop over the items attached to a
node. Here is an example of adj.c code that uses a @code{AdjIterator},
@code{adjExists}.

@verbatim
GridBool adjExists( Adj *adj, int node, int item )
{
  AdjIterator it;
  GridBool exist;
  exist = FALSE;
  for ( it = adjFirst(adj,node); 
	!exist && adjValid(it); 
	it = adjNext(it)) 
    exist = (item == adjItem(it));
  return exist;
}
@end verbatim

Use @code{adjRealloc} to change the number of nodes. Additional items are
automatically reallocated in @code{adjChunkSize} blocks.

@section Queue
@cindex queue

The queue object stores transactions to comminucate connectity changes
(i.e., edge swaps and node insertion) across processors during
parallel grid adaptation operations. A queue object is created with
@code{queueCreate}. The @code{nodeSize} argument specifies how many
doubles will be stored for each node. 

A new transaction started with a call to @code{queueNewTransaction}.
The @code{queueReset} clears all existing tranactions. A transaction
is composed of @code{queueRemoveCell}, @code{queueAddCell},
@code{queueRemoveFace}, @code{queueAddFace}, @code{queueRemoveEdge},
@code{queueAddEdge} calls.

Existing transactions can be queried with the
@code{queueRemovedCells}, @code{queueAddedCells},
@code{queueRemovedFaces}, @code{queueAddedFaces},
@code{queueRemovedEdges}, @code{queueAddedEdges} method to obtain
counts of the element changes. Running totals of cells, faces, and
edges are used the accesses the actual data in the rest of the
@code{queueRemoved*} and @code{queueAdded*} routines.

A queue object can be message passed to other processors by extracting
two arrays, sending them, and using these arrays to recreate the queue
object. All the internal data structures of a queue can be dumped to a
single array of @code{int}s and a single array of @code{double}s. The
sizes of these arrays are given by @code{queueDumpSize}. The arrays
are filled by the @code{queueDump} method. The arrays can be used to
fill the queue object's data structures with the @code{queueLoad}
method.

@section Sort
@cindex sort

The sort object contains a heap sort routine @code{sortHeap} and a
binary search routine for sorted elements @code{sortSearch}.

@node Grid Object
@chapter Grid Object
@cindex object, grid

The grid object contains all the data for the grid. It contains a
number of the base objects. It automatically reallocates data to grow
with the grid. A grid object is created @code{gridCreate} with an
estimate of max number of nodes, cells, faces, and edges.

Empty spaces in node and element arrays (created as the result of
removal form mesh) are removed the the arrays compacted with
@code{gridPack}. The nodes (and face) can be sorted to GridEx
@code{gridSortNodeGridEx} and FUN3D conventions @code{gridSortFUN3D}.

A grid object can be imported from arrays
@code{gridImport} or a FAST file @code{gridImportFAST}.

A grid object can be exported as arrays @code{gridExport}, a FAST file
@code{gridExportFAST} or AFLR3 file @code{gridExportAFLR3}. The
surface (faces) can be displayed with
@code{gridWriteTecplotSurfaceZone}. NOTE: the export routines may
evoke pack @code{gridPack} and sort routines @code{gridSort*}.

Grid children can register methods to handle packing, reordering,
reallocation, and deallocation, see @code{gridAttach*}. These
registered methods can be unregistered with @code{gridDetach*}.

Stuff can be added and removed with @code{gridAdd*} and
@code{gridRemove*}. Remove operations leave empty spaces in arrays. To
iterate over items, loop out to max array size and test each item to
see if it is valid. 

@verbatim
int cell;
for ( cell = 0 ; cell < gridMaxCell(grid) ; cell++ ) {
  if ( gridCellValid(grid,cell) ) {
    printf ( "cell %d is valid.\n", cell );
  } 
}
@end verbatim

A gem is the set of cells that surround an edge. It is used for edge
swapping, node insertion, and edge collapse. A gem is formed with
@code{gridMakeGem}. An equator @code{gridEquator} can be formed from a
gem. An equator is an ordered set of nodes in a gem that are not
part of the edge in the center of the gem.

The map @code{gridMap} is six entries of a 3x3 symmetric matrix used
to define an anisotropic grid metric.

@node Grid Mix-ins
@chapter Grid Mix-ins
@cindex mix-in, grid

@heading Grid Mix-ins
@enumerate
@item gridmath - basic vector and matrix math routines
@item gridmetric - computes element metrics (volume, aspect ratio)
@item gridswap - edge and face swapping routines
@item gridcad - node projection and node smoothing for improved element quality
@item gridgeom - parallel GeoSDK/CAPRI restart routines
@item gridinsert - inserts and removes nodes into grid
@item gridmpi - parallel grid adaptation helper
@item gridfortran - fortran bindings for linking to FUN3D
@end enumerate

@section GridMath
@cindex gridmath

Basic vector and matrix math routines

@section GridMetric
@cindex gridmetric

Computes the length of an edge in physical space and
@code{gridEdgeLength} in mapped space with an average metric
@code{gridEdgeRatio}. Finds longest @code{gridLargestRatioEdge} and
shortest @code{gridSmallestRatioEdge} with an average metric
applied. 

Converts a metric M to a jacobian J
@code{gridConvertMetricToJacobian}. Apply a jacobian to a XYZ value
@code{gridMapXYZWithJ}.

Computes element volume @code{gridVolume} in physical space and aspect
ratio @code{gridAR} in metric mapped space. The aspect ration of the
worst elements around a node is provided by the @code{gridNodeAR}
function. The same info is available for faces @code{gridFaceArea}
@code{gridFaceAR}. These routines have also been differentiated.

@section GridSwap
@cindex gridswap

The gridswap mix-in allows modification of grid connectivites by face
@code{gridSwapFace} and edge @code{gridSwapEdge} swapping. There is a
special routine that cleans up cells with two faces the surface
@code{gridRemoveTwoFaceCell}. These two face cells are very
troublesome for projection. The @code{gridSwapEdge} and
@code{gridRemoveTwoFaceCell} have been parallelized. (The
@code{gridSwapFace} routine could easily be parallelized, but this has
not been completed.) The parallelization is enabled by populating a
@code{queue} object, which is broadcast to other processors and
applyed to keep the connectivities on all  processors consistent.

@section GridCAD
@cindex gridcad

The gridcad mix-in enables projection of grid nodes to geometry
objects with CADGeom routines. CADGeom uses CAPRI for CAD acesses and
storing files. Node smoothing and untangling is implemented for
interior nodes and nodes on CAD surfacces.

@section GridGeom
@cindex gridgeom

The gridgeom object provides the methods to read and write GeoSDK
CARPI restart files in parallel. It currently is not unit tested.

@section GridInsert
@cindex gridinsert

The gridinsert object provides mix-in methods to the grid object to
facilitate adding and removing nodes from an existing mesh. Nodes are
most often added by splitting a edge in half. Nodes are removed by
collapsing edges. Nodes insertion by edge splitting has been fully
parallelized with the queue object. Node removal by edge collapse can
currently be performed for the interior of a parallel partition, but
not boundary regions between partitions. There are also routines to
insert nodes on cell faces and the interior of cells, but these
routines have not been parallelized and they contain slow searches for
host elements.

@section GridMPI
@cindex gridmpi

The @code{gridmpi} adds functionality for parallel processing. It
provides parallel safe versions of various grid modifing routines
@code{gridParallel*}. It does not perform the MPI communication
directly. The actual MPI communication must be performed by a host MPI
application. A @code{queue} object can be used to update a grid's
connectivities with the @code{gridApplyQueue} method.

@section GridFORTRAN
@cindex gridfortran

The @code{gridfortran} mixin contins FORTRAN bindings for
FUN3D. Currently, only FORTRAN binding with one underscore are
provided. Additional bindings can be added for compatability with more
FORTRAN compilers. The @code{gridfortran} mixin stores static pointers
to the @code{grid}, @code{gridmove}, and @code{queue} objects to allow
FORTRAN routines to use refine. This mixin contains routines to
convert a C grid object from a FUN3D FORTRAN grid derived type and
back again.

Much of the low-level MPI interface is provided in this mixin. This
includes sizing, packing, and unpacking messages to send to and from
other processors.

@node Running FUN3D
@chapter Running FUN3D
@cindex FUN3D, Running

@section Adaptation workflow

There is an @code{if (adapt) then} block named in
Adjoint/rad_module.f90 that controls the high level workflow of the
adaptation process.

There are to basic parallelization strategies employed in the coupled
FUN3D and refine library execution. The first allows for the movement
of nodes with constant connectivities. The second allows for changes
in connectivity.

@section Parallelized Node Movement

An example of a node movement routine with constant connectivities is
@code{refineParallelSmooth} in
HEFSS.rps/LibF90/refine_interface.F90. There are two passes to the
parallelization logic.

The first allows all processors to move nodes that are internal to the
processor. Nodes are considered internal if they are not connect to
ghost nodes by any elements. This parallel internal pass is performed
by setting the first argument (processor) to -1 for
@code{gridparallelsmooth}.

Then each processor is allowed to modify the boundary region, which is
the local nodes that are connected to other processor ghost nodes with
elements. This modification is done by each processor in turn, with
the other processors waiting for the active processor to finish its
work.

After a processor finished modifying its border region,
@code{refineUpdateGhostXYZ} is called to broad cast any changes to the
other processors. The @code{refineUpdateGhostXYZ} routine updates the
face UV parameters and the edge T parameter as well as the node XYZ's.

The @code{gridmove} child object has a slightly different methodology
for parallelization. It needs to do hundreds of operations similar to
@code{refineUpdateGhostXYZ} to a different vector, the grid movement
displacements. Also, the communication pattern is constant for each
grid movement operation.

A LibF90/refine_interface.F90:@code{refineParallelProjectGridMove}
starts by precomputing and storing the communication pattern that will
be required. It then calls @code{refineUpdateGridMoveGhost} with the
stored communication pattern to update ghost node displacements.

@section Parallelized Connectivity Changes

The swap, node insertion, and edge collapse routines share the same
strategy for parallelization. The node insertion, and edge collapse
routines are combined into @code{refineParallelAdapt}. The
@code{gridParallelSwap} routine will be used as an exaple to
illustrate the parallelization scheme that is common to
@code{gridParallelSwap} and @code{refineParallelAdapt} routines.

First, internal
connnectivites (elements not near ghost nodes) are modified. This
parallel internal pass is performed by setting the first argument
(processor) to -1 for @code{gridparallelswap}.

When new elements or nodes are created, they are assigned global
numbering by incrementing the total global count of nodes or
elements. This leads to overlaps in the global numberings of different
elements on different processors. This overlap is fixed by shifting
the global numbering with the @code{sync_global_numbering} subroutine,
which requires the global node and cell count from before the
connectitives where changed.

To change the connectities in the ghost region, a loop over processors
is performed. Other processors wait for the the active processor to
complete its connectivity changes. After the active processor makes
its changes, everyone calls @code{sync_global_numbering} to update
global node and cell counts (offsets do not need to be performed). A
@code{queue} object is used to communicate ghost region connectivity
changes to other processors. It is filled by the changes on the active
processor and then serialized with @code{queueDump}. This serialized
object is broadcast, reinstated, and used to update other processors
@code{gridApplyQueue}.

Note that the number of global nodes and cells is only incremented in
this process. Removed global numbering are stored locally on each
processor for reuse. Therefore, when a processor takes ownership of a
global index it always has it and no other processor can use
it. These unused global numberings are cleaned up at the end of the
adaptation process with @code{eliminate_unused_globals}.

@section Initial notes on building and executing HEFSS with the rad mesh adapation option.

@verbatim
cvs -d :ext:geolab:/usr/local/inhouse/CVS co CAPRI
cvs -d :ext:geolab:/usr/local/inhouse/CVS co SDK
cvs -d :ext:cmb20:/ump/fldmd/home/mikepark/cvsroot co refine
@end verbatim

User can define locations of components (modeling kernels, libraries,
etc) either as command line arguments to configuration scripts or as
environment variables that will be used as defaults by the
configuration scripts.  The components of interest are:

@verbatim
  Component      (Environment variable)
  GEOLAB SDK     ($GEO_SDK)
  CAPRI          ($CAPRI_ROOT and $CAPRI_ARCH)
  refine         ($REFINELib)
  Geometry modeling kernels,
    PARASOLID    ($PARASOLID and $P_SCHEMA)
    PRO/Engineer ($PRODIR)
    OpenCASCADE  ($CASROOT)
@end verbatim

Here we will elect to set environment variables up front.

@verbatim
  setenv CAPRI_ROOT `pwd`/CAPRI
  setenv GEO_SDK `pwd`/SDK/`uname`
  setenv REFINELib `pwd`/refine/`uname`
@end verbatim

The autogen.sh script will create AND run the GNU Autotools configure
script.  Any arguments that might be needed by configure can be given
to autogen.sh (i.e. in lew of using environment variables).  (Ex:
./autogen --with-CAPRI=... instead of setenv CAPRI_ROOT ...)

The SDK is only dependent on CAPRI (no modelers needed) so we will
simply configure with no arguments noting that $CAPRI_ROOT was set
above.

@code{./autogen.sh}

@verbatim
ls

AUTHORS     GeoMap/      Makefile     RacerX/          config.guess*  ltmain.sh
CADGeom/    GeoObjects/  Makefile.Z   UG_API/          config.sub*    missing*
COPYING     Goolache/    Makefile.am  aclocal.m4       configure*
CVS/        GravyLib/    Makefile.in  autogen.sh*      configure.ac
ChangeLog   INSTALL      MeatLib/     autom4te.cache/  depcomp*
Cranberry/  IRIX64/      NEWS         bootstrap*       install-sh*
Fruitcake/  Linux/       README       compile*         libltdl/

cd `uname`
make
make install
[geowulf.larc.nasa.gov Linux]$ ls
CADGeom/    GeoMap/    Makefile  UG_API/     config.status*  libltdl/
Cranberry/  Goolache/  MeatLib/  bin/        include/        libtool*
Fruitcake/  GravyLib/  RacerX/   config.log  lib/            translators/
@end verbatim

Refine will be built against the FELISA Native modeling kernel by
default.  To enable other modelers, either set the environment
variables above or configure with command line arguments that enable
them (configure --help will list the command line args and syntax)

@verbatim
cd ../../refine
./autogen.sh
cd `uname`
make
make install
[geowulf.larc.nasa.gov Linux]$ ls
CVS/      bin/        config.status*  example/     include/  lib/
Makefile  config.log  doc/            geomSGIn32/  info/     src/
@end verbatim

Now for HEFSS

Must set $GEO_SDK and $REFINElib prior to runing HEFSS ./Configure
(see the geowulf host settings for details about building against
refine) 
@verbatim
  cd HEFSS.rps
  make
@end verbatim

@verbatim
cd refine/example
[geowulf.larc.nasa.gov example]$ ls
CVS/               Makefile.in   om6p01.capri   om6ref.m
DebugRunAdapt.rb*  RunAdapt.rb*  om6p01.dat     papmachtop04aniso.lay
FlowConditions.rb  om6mach84.m   om6p01.fastbc  papmachtop06.lay
Makefile.am        om6p01.bac    om6p01.fgrid   propagateLay.rb*

mkdir Flow Adjoint
@end verbatim

edit RunAdapt.rb Change $hefssRoot to the location of your working
copy of HEFSS (i.e.$hefssRoot = ' /scratchZZ:q!/HEFSS.rps').  Other
variables of interest include
@verbatim
    projectRoot  -
    do |n|       - number of adaptation cycles (defaults 1-6)
    numberOfPart - number of partitions
    outputError  - error tolerance
    maxAR        - allowable aspect ratio
    maxEdge      - allowed edge length.
@end verbatim

Edit FlowConditions .rb and make any desired changes as key/value
pairs to replace default ginput.faces file of HEFSS installation.

@code{./RunAdapt.rb}
  You can monitor progress of rad with `tail -F Adjoint/rad_out`
  Output

@node Support
@chapter Support
@cindex support

@section Making a distribution
@cindex distribution

If anything has changed in the GEOLAB SDK up date the static snapshots
of the libraries in geomSGIn32. Build these on an SGI with the legecy
SDK Makefiles. MeatLib is created wiht @code{make sgi} and CADGeom is
created with @code{make alan}.

In preparation to creating a distribution edit the @code{ChangeLog},
@code{NEWS} and @code{configure.ac} files.

@enumerate
@item @code{ChangeLog} - contains detailed summaries of changes.
@item @code{NEWS} - contains an overview of changes between releases.
@item @code{configure.ac} - the release version is set and the second argument to @code{AM_INIT_AUTOMAKE([refine],[version])}
@end enumerate

First add an entry to the Change log that looks like:

@verbatim
2004-08-17 12:55 FirstName LastName  <myEMail@nasa.gov>

	* Made 1.2.2 Release. Interface to FUN3D 3.3.1.

@end verbatim

Note that * is proceeded by a tab and that any compatibility issues
with specific FUN3D and the SDK versions should be listed.

Next, summarize the changes listed in the ChangeLog between now and
the last distribution and put them in the NEWS file. Again, note any
compatibility issues with specific versions of FUN3D and the SDK
should be noted.

Commit your changes to @code{ChangeLog}, @code{NEWS} and
@code{configure.ac} and tag the repository.

A distribution is created by typing @code{make dist} where you have
configured the package.

After you have created a distribution increment the version string at
the top of configure.ac to the next test release.

@node Add Me
@chapter Add Me

Put your documentation wish list here.

@enumerate
@item FORTRAN stuff: rad_module workflow.
@end enumerate

@node Index
@unnumbered Index

@printindex cp

@bye
