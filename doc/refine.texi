\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename refine.info
@settitle Refine Library Manual
@c %**end of header

@c @copying
@c The refine library overview, version 1.0.
@c @end copying

@titlepage
@title Refine Library Manual

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@c @insertcopying
The refine library overview, version 1.0.
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top
@top Refine Library Manual

@c @insertcopying
@end ifnottex

@menu
* Introduction :: Short description.
* Overview ::     Basic architecture
* Base Objects :: Base objects for grid.
* Grid Object  :: The main object: grid.
* Index ::        Complete index.
@end menu

@node Introduction
@chapter Introduction
@cindex introduction

This is a copy of refine/README file from the distribution.

Refine is a 3D tetrahedral grid adaptation framework. It is
implemented with an object-oriented flavor in the C language.  Most
functionality is wrapped into Ruby scripting language extensions
@code{http://www.ruby-lang.org/} for use in test first programing and unit
testing. See the README.EXT file in the Ruby distribution for details
on ruby extensions.
 
The refine library can be called by FUN3D @code{http://fun3d.larc.nasa.gov/}
to perform adaptation with a parallel execution scheme.
 
CAD geometry access is facilitated with the NASA Langley Geomerty
Labratory SDK @code{http://geolab.larc.nasa.gov/}, which assess CAD
information with the CAPRI API
@code{http://raphael.mit.edu/capri/docs.html}.

MesherX is an advancing layer mixed-element mesher that interacts
with the SDK to rebuild the inviscid portions of the grid. 

@node Overview
@chapter Overview
@cindex overview

@section Conventions
@cindex conventions

The term `object' will be used loosely in this manual. An object
defined is a pointer to a C structure with its assoicated methods that
are generally bundled into a C header and source file. I got this idea
from the way that the Ruby interpreture is writen in C.

NOTE: although the C strut of the objects is often exposed for macro
acess to increasing efficiency, please DO NOT acess them directly, use
the available methods or macros.

A pointer to a C struct is passed as the first argument to `object'
methods. These methods generally return @code{NULL} or @code{EMPTY
(-1)} when they fail. They return a C struct pointer (often the first
argument) or the result if they are sucessful.

@section Architecture
@cindex architecture

The refine library is composed of base objects, the grid object, grid
mix-ins, child objects, and others. Items denoted with (M) or (R) are
only used with MesherX (M) or the stand-alone sequential refine
executable (R).

@heading Base objects:
@enumerate
@item adj - element node adjacency
@item queue - transaction queue for parallel connectivity modifcations.
@item sort - list sorting and searching routines.
@item line - stores arrays of nodes (advancing layer growth curves).
@item near - near tree for finding nearby things (M)
@item intersect - computes if elements intersect. (M)
@end enumerate

@heading Grid Object:
@enumerate
@item grid - stores majority of grid data and low-level methods.
@end enumerate

@heading Grid Mix-ins
@enumerate
@item gridmath - basic vector and matrix meth routines
@item gridmetric - computes element metrics (volume, aspect ratio)
@item gridswap - edge and face swapping routines
@item gridcad - node projection and node smoothing for improved element quality
@item gridgeom - parallel GeoSDK/CAPRI restart routines.
@item gridinsert - inserts and removes nodes into grid.
@item gridmpi - parallel grid adaptation helper
@item gridfortran - fortran bindings for linking to FUN3D.
@item gridfiller - sequental GeoSDK/CAPRI restart routines. (M,R)
@end enumerate

@heading Grid Children
@enumerate
@item gridmove - grid movement by linear elasticity or springs (inherts form grid)
@item layer - advancing layer mesher object. (M)
@end enumerate

@heading Others
@enumerate
@item refine_main - stand-alone refine main. (R)
@item MesherX - MesherX main. (M)
@item mesherx - MesherX driver routines. (M)
@item mesherxInit - Build layer object from GeoSDK/CAPRI restart. (M)
@item mesherxRebuild - Inviscid mesh rebuild routines for advaning layer meshes. (M)
@end enumerate

@node Base Objects
@chapter Base Objects
@cindex object, base

The most important refine library base objects are adj, queue, and sort.

@section Adj
@cindex adj

The adj object stores the adjacency of items (elements) to nodes. It
has the ability to be dynamically resized and grown. It is initialized
@code{adjCreate} with the max node count, max adjacency, and a chunk
size for growing more adjacencies.

A new item adjacency is added with @code{adjRegister} method by
specifing a node and integer item index. It can also be removed with
@code{adjRemove}. A node's item count is @code{adjDegree}. The
presence of a item attached to a node is tested with @code{adjExists}.

To loop over the items attached to a node use a
@code{AdjIterator}. Here is an example of adj.c code that uses a
@code{AdjIterator}, @code{adjExists}.

@verbatim
GridBool adjExists( Adj *adj, int node, int item )
{
  AdjIterator it;
  GridBool exist;
  exist = FALSE;
  for ( it = adjFirst(adj,node); 
	!exist && adjValid(it); 
	it = adjNext(it)) 
    exist = (item == adjItem(it));
  return exist;
}
@end verbatim

Use @code{adjRealloc} to change the number of nodes. Additional items are
automatically reallocated in @code{adjChunkSize} blocks.

@section Queue
@cindex queue

The queue object stores transactions to comminucate connectity changes
(i.e., edge swaps and node insertion) across processers durring
parallel grid adaptation operations. A queue object is created with
@code{queueCreate}. The @code{nodeSize} argument specifies how many
doubles will be stored for each node. 

A new transaction started with a call to @code{queueNewTransaction}.
The @code{queueReset} clears all existing tranactions. A transaction
is composed of @code{queueRemoveCell}, @code{queueAddCell},
@code{queueRemoveFace}, @code{queueAddFace}, @code{queueRemoveEdge},
@code{queueAddEdge} calls.

Existing transactions can be queried with the
@code{queueRemovedCells}, @code{queueAddedCells},
@code{queueRemovedFaces}, @code{queueAddedFaces},
@code{queueRemovedEdges}, @code{queueAddedEdges} method to obtain
counts of the element changes. Running totals of cells, faces, and
edges are used the acesses the actual data in the rest of the
@code{queueRemoved*} and @code{queueAdded*} routines.

A queue object can be message passed to other processors by extracting
two arrays, sending them, and using these arrays to recreate the queue
object. All the internal data sturctures of a queue can be dumped to a
single array of @code{int}s and a single array of @code{double}s. The
sizes of these arrays are given by @code{queueDumpSize}. The arrays
are filled by the @code{queueDump} method. The arrays can be used to
fill the queue object's data structures with the @code{queueLoad}
method.

@section Sort
@cindex sort

The sort object contains a heap sort routine @code{sortHeap} and a
binary search routine for sorted elements @code{sortSearch}.

@node Grid Object
@chapter Grid Object
@cindex object, grid

The grid object contains all the data for the grid. It contains a
number of the base objects. It automatically reallocates data to grow
with the grid. A grid object is created @code{gridCreate} with an
estimate of max number of nodes, cells, faces, and edges.

Empty spaces in node and element arrays (created as the result of
removal form mesh) are removed the the arrays compacted with
@code{gridPack}. The nodes (and face) can be sorted to GridEx
@code{gridSortNodeGridEx} and FUN3D conventions @code{gridSortFUN3D}.

A grid object can be imported from arrays
@code{gridImport} or a FAST file @code{gridImportFAST}.

A grid object can be exported as arrays @code{gridExport}, a FAST file
@code{gridExportFAST} or AFLR3 file @code{gridExportAFLR3}. The
surface (faces) can be displayed with
@code{gridWriteTecplotSurfaceZone}. NOTE: the export routines may
envoke pack @code{gridPack} and sort routines @code{gridSort*}.

Grid children can register methods to handle packing, reordering,
reallocation, and deallocation @code{gridAttach*}. These registered
methods can be unregistered with @code{gridDetach*}.

@node Index
@unnumbered Index

@printindex cp

@bye
