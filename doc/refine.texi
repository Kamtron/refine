\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename refine.info
@settitle Refine Library Manual
@c %**end of header

@c @copying
@c The refine library overview, version 1.0.
@c @end copying

@titlepage
@title Refine Library Manual

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@c @insertcopying
The refine library overview, version 1.0.
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top
@top Refine Library Manual

@c @insertcopying
@end ifnottex

@menu
* Introduction  :: Short description.
* Overview      :: Basic architecture
* Base Objects  :: Base objects for grid.
* Grid Object   :: The main object: grid.
* Grid Mix-ins  :: Additional methods for grid object
* Add Me        :: Documentation Wish List.
* Running FUN3D :: HOWTO run FUN3D with refine
* Index         :: Complete index.
@end menu

@node Introduction
@chapter Introduction
@cindex introduction

This is a copy of refine/README file from the distribution.

Refine is a 3D tetrahedral grid adaptation framework. It is
implemented with an object-oriented flavor in the C language.  Most
functionality is wrapped into Ruby scripting language extensions
@url{http://www.ruby-lang.org/} for use in test first programing and unit
testing. See the README.EXT file in the Ruby distribution for details
on ruby extensions.
 
The refine library can be called by FUN3D @url{http://fun3d.larc.nasa.gov/}
to perform adaptation with a parallel execution scheme.
 
CAD geometry access is facilitated with the NASA Langley Geomerty
Labratory SDK @url{http://geolab.larc.nasa.gov/}, which assess CAD
information with the CAPRI API
@url{http://raphael.mit.edu/capri/docs.html}.

MesherX is an advancing layer mixed-element mesher that interacts
with the SDK to rebuild the inviscid portions of the grid. 

@node Overview
@chapter Overview
@cindex overview

@section Conventions
@cindex conventions

The term `object' will be used loosely in this manual. An object
defined is a pointer to a C structure with its assoicated methods that
are generally bundled into a C header and source file. I got this idea
from the way that the Ruby interpreture is writen in C.

NOTE: although the C strut of the objects is often exposed for macro
acess to increasing efficiency, please DO NOT acess them directly, use
the available methods or macros.

A pointer to a C struct is passed as the first argument to `object'
methods. These methods generally return @code{NULL} or @code{EMPTY
(-1)} when they fail. They return a C struct pointer (often the first
argument) or the result if they are sucessful.

@section Architecture
@cindex architecture

The refine library is composed of base objects, the grid object, grid
mix-ins, child objects, and others. Items denoted with (M) or (R) are
only used with MesherX (M) or the stand-alone sequential refine
executable (R).

@heading Base objects:
@enumerate
@item adj - element node adjacency
@item queue - transaction queue for parallel connectivity modifcations.
@item sort - list sorting and searching routines.
@item line - stores arrays of nodes (advancing layer growth curves).
@item near - near tree for finding nearby things (M)
@item intersect - computes if elements intersect. (M)
@end enumerate

@heading Grid Object:
@enumerate
@item grid - stores majority of grid data and low-level methods.
@end enumerate

@heading Grid Mix-ins
@enumerate
@item gridmath - basic vector and matrix math routines
@item gridmetric - computes element metrics (volume, aspect ratio)
@item gridswap - edge and face swapping routines
@item gridcad - node projection and node smoothing for improved element quality
@item gridgeom - parallel GeoSDK/CAPRI restart routines.
@item gridinsert - inserts and removes nodes into grid.
@item gridmpi - parallel grid adaptation helper
@item gridfortran - fortran bindings for linking to FUN3D.
@item gridfiller - sequental GeoSDK/CAPRI restart routines. (M,R)
@end enumerate

@heading Grid Children
@enumerate
@item gridmove - grid movement by linear elasticity or springs (inherts form grid)
@item layer - advancing layer mesher object. (M)
@end enumerate

@heading Others
@enumerate
@item refine_main - stand-alone refine main. (R)
@item MesherX - MesherX main. (M)
@item mesherx - MesherX driver routines. (M)
@item mesherxInit - Build layer object from GeoSDK/CAPRI restart. (M)
@item mesherxRebuild - Inviscid mesh rebuild routines for advaning layer meshes. (M)
@end enumerate

@section Unit Testing
@cindex test, unit

Each of the objects listed in the previous ``Architecture'' section is composed of four files:

@enumerate
@item @code{anobjectMT.rb} - Ruby unit test script, This contains the object's Mobility Test (MT).
@item @code{anobject_ruby.c} - Ruby wrapper code to allow Ruby to load the objecty.
@item @code{anobject.h} - C header file
@item @code{anobject.c} - C source file.
@end enumerate

When the @code{anobjectMT.rb} script is envoked, it first calls
@code{RubyExtensionBuilder.rb}. The @code{RubyExtensionBuilder.rb}
script handles any dependencies by making any ruby extensions that the
@code{anobjectMT.rb} script requires to run. Each object is created
with the @code{makeRubyExtension.rb} script. The
@code{makeRubyExtension.rb} script C creates a subdirectory named
AnObject. Inside this directory the standard Ruby @code{mkmf.rb}
module is envoked to create a makefile, which is used to create a
shared object. The shared object is loaded into the
@code{anobjectMT.rb} script with
@verbatim
  require 'AnObject/AnObject'
@end verbatim

Any other objects that are required by AnObject will also need to be
added to the top of @code{AnObject.rb}. If the object is a mixin, you
will need to add is methods to a base object after it has been
require'd. This following example from @code{gridmetricMT.rb} adds the
gridmetic mix-in methods to the grid object.

@verbatim
class Grid
 include GridMetric
end
@end verbatim

@node Base Objects
@chapter Base Objects
@cindex object, base

The most important refine library base objects are adj, queue, and sort.

@section Adj
@cindex adj

The adj object stores the adjacency of items (elements) to nodes. It
has the ability to be dynamically resized and grown. It is initialized
@code{adjCreate} with the max node count, max adjacency, and a chunk
size for growing more adjacencies.

A new item adjacency is added with @code{adjRegister} method by
specifing a node and integer item index. It can also be removed with
@code{adjRemove}. A node's item count is @code{adjDegree}. The
presence of a item attached to a node is tested with @code{adjExists}.

To loop over the items attached to a node use a
@code{AdjIterator}. Here is an example of adj.c code that uses a
@code{AdjIterator}, @code{adjExists}.

@verbatim
GridBool adjExists( Adj *adj, int node, int item )
{
  AdjIterator it;
  GridBool exist;
  exist = FALSE;
  for ( it = adjFirst(adj,node); 
	!exist && adjValid(it); 
	it = adjNext(it)) 
    exist = (item == adjItem(it));
  return exist;
}
@end verbatim

Use @code{adjRealloc} to change the number of nodes. Additional items are
automatically reallocated in @code{adjChunkSize} blocks.

@section Queue
@cindex queue

The queue object stores transactions to comminucate connectity changes
(i.e., edge swaps and node insertion) across processers durring
parallel grid adaptation operations. A queue object is created with
@code{queueCreate}. The @code{nodeSize} argument specifies how many
doubles will be stored for each node. 

A new transaction started with a call to @code{queueNewTransaction}.
The @code{queueReset} clears all existing tranactions. A transaction
is composed of @code{queueRemoveCell}, @code{queueAddCell},
@code{queueRemoveFace}, @code{queueAddFace}, @code{queueRemoveEdge},
@code{queueAddEdge} calls.

Existing transactions can be queried with the
@code{queueRemovedCells}, @code{queueAddedCells},
@code{queueRemovedFaces}, @code{queueAddedFaces},
@code{queueRemovedEdges}, @code{queueAddedEdges} method to obtain
counts of the element changes. Running totals of cells, faces, and
edges are used the acesses the actual data in the rest of the
@code{queueRemoved*} and @code{queueAdded*} routines.

A queue object can be message passed to other processors by extracting
two arrays, sending them, and using these arrays to recreate the queue
object. All the internal data sturctures of a queue can be dumped to a
single array of @code{int}s and a single array of @code{double}s. The
sizes of these arrays are given by @code{queueDumpSize}. The arrays
are filled by the @code{queueDump} method. The arrays can be used to
fill the queue object's data structures with the @code{queueLoad}
method.

@section Sort
@cindex sort

The sort object contains a heap sort routine @code{sortHeap} and a
binary search routine for sorted elements @code{sortSearch}.

@node Grid Object
@chapter Grid Object
@cindex object, grid

The grid object contains all the data for the grid. It contains a
number of the base objects. It automatically reallocates data to grow
with the grid. A grid object is created @code{gridCreate} with an
estimate of max number of nodes, cells, faces, and edges.

Empty spaces in node and element arrays (created as the result of
removal form mesh) are removed the the arrays compacted with
@code{gridPack}. The nodes (and face) can be sorted to GridEx
@code{gridSortNodeGridEx} and FUN3D conventions @code{gridSortFUN3D}.

A grid object can be imported from arrays
@code{gridImport} or a FAST file @code{gridImportFAST}.

A grid object can be exported as arrays @code{gridExport}, a FAST file
@code{gridExportFAST} or AFLR3 file @code{gridExportAFLR3}. The
surface (faces) can be displayed with
@code{gridWriteTecplotSurfaceZone}. NOTE: the export routines may
envoke pack @code{gridPack} and sort routines @code{gridSort*}.

Grid children can register methods to handle packing, reordering,
reallocation, and deallocation @code{gridAttach*}. These registered
methods can be unregistered with @code{gridDetach*}.

Stuff can be added and removed with @code{gridAdd*} and
@code{gridRemove*}. Remove operations leave empty spaces in arrays. To
iterate over items, loop out to max array size and test each item to
see if it is vaild. 

@verbatim
int cell;
for ( cell = 0 ; cell < gridMaxCell(grid) ; cell++ ) {
  if ( gridCellValid(grid,cell) ) {
    printf ( "cell %d is valid.\n", cell );
  } 
}
@end verbatim

A gem is the set of cells that surround an edge. It is used for edge
swapping, node insertion, and edge collapse. A gem is formed with
@code{gridMakeGem}. An equator is an ordered set of nodes in a geom
that are not defineig the edge.

The map @code{gridMap} is six entries of a 3x3 symmetric matrix used
to define an anisotropic grid metric.

@node Grid Mix-ins
@chapter Grid Mix-ins
@cindex mix-in, grid

@heading Grid Mix-ins
@enumerate
@item gridmath - basic vector and matrix math routines
@item gridmetric - computes element metrics (volume, aspect ratio)
@item gridswap - edge and face swapping routines
@item gridcad - node projection and node smoothing for improved element quality
@item gridgeom - parallel GeoSDK/CAPRI restart routines.
@item gridinsert - inserts and removes nodes into grid.
@item gridmpi - parallel grid adaptation helper
@item gridfortran - fortran bindings for linking to FUN3D.
@end enumerate

@section GridMath
@cindex gridmath

Basic vector and matrix math routines

@section GridMetric
@cindex gridmetric

Computes the length of an edge in physical space and
@code{gridEdgeLength} in mapped space with an average metric
@code{gridEdgeRatio}. Finds longest @code{gridLargestRatioEdge} and
shortest @code{gridSmallestRatioEdge} with an average metric
applied. 

Converts a metric M to a jacobian J
@code{gridConvertMetricToJacobian}. Apply a jacobian to a XYZ value
@code{gridMapXYZWithJ}.

Computes element volume @code{gridVolume} in physical space and aspect
ratio @code{gridAR} in metric mapped space. This methods call also be
called on elements arround a node @code{gridNodeAR}. The same info is
available for faces @code{gridFaceArea} @code{gridFaceAR}. These
routines have also been differentiated.

@section GridSwap
@cindex gridswap

The gridswap mix-in allows modification of grid connectivites by face
@code{gridSwapFace} and edge @code{gridSwapEdge} swapping. There is a
special routine that cleans up cells with two faces the surface
@code{gridRemoveTwoFaceCell}. These two face cells are very
troublesome for projection. The @code{gridSwapEdge} and
@code{gridRemoveTwoFaceCell} have been parallelized. (The
@code{gridSwapFace} routine could easily be parallelized, but this has
not been gotten to yet.) The parallelization is enmabled by populating
a queue opject, which is broadcast to other processors and applyed to
keep other processors up to date.

@section GridCAD
@cindex gridcad

The gridcad mix-in enables projection of grid nodes to geometry
objects with CADGeom routines. CADGeom uses CAPRI for CAD acesses and
storing files. Node smoothing and untangling in also implemented for
surface nodes and nodes on CAD surfacces.

@section GridGeom
@cindex gridgeom

The gridgeom object provides the methods to read and write GeoSDK
CARPI restart files in parallel. It currently is not unit tested.

@section GridInsert
@cindex gridinsert

The gridinsert object provides mix-in methods to the grid object to
facilitate adding and removing nodes from an existing mesh. Nodes most
often added by splitiing a edge in half. Nodes are removed by
collapsing edges. Nodes insertion by edge splitting has been fully
parallelized with the queue object. Node removal by egde collapse can
currently be performed for the interior of a parallel partition, but
not boundary regions between partitions. There are also routines to
insert nodes on cell faces and the interior of faces, but these
routines have not been parallelized.

@section GridMPI
@cindex gridmpi

Added functionality for parallel processing.

@section GridFORTRAN
@cindex gridfortran

FORTRAN bindings for FUN3D.

@node Add Me
@chapter Add Me

Doc wish list

FORTRAN stuff:

parallel scheme (describe refine_interface)

node updates:

processor = 1 allows only partion interior modifications.  the
interior of the pasrtions does not affect other partionions.  Below
loop will initially will modify partition interior, and then will
modify its boundaries.  Note: loop executing on each processor.  Will
first modify interior and then wait until it is its turn
...refineUpdateGhostXYZ() will block


connentivity updates.



rad_module workflow.


@node Running FUN3D
@chapter Running FUN3D
@cindex FUN3D, Running

@section Initial notes on building and executing HEFSS with the rad mesh adapation option.

@verbatim
cvs -d :ext:geolab:/usr/local/inhouse/CVS co CAPRI
cvs -d :ext:geolab:/usr/local/inhouse/CVS co SDK
cvs -d :ext:cmb20:/ump/fldmd/home/mikepark/cvsroot co refine
@end verbatim

User can define locations of components (modeling kernels, libraries, etc) either as command line arguments to configuration scripts or as environment variables that will be used as defaults by the configuration scripts.  The components of interest are:

@verbatim
  Component      (Environment variable)
  GEOLAB SDK     ($GEO_SDK)
  CAPRI          ($CAPRI_ROOT and $CAPRI_ARCH)
  refine         ($REFINELib)
  Geometry modeling kernels,
    PARASOLID    ($PARASOLID and $P_SCHEMA)
    PRO/Engineer ($PRODIR)
    OpenCASCADE  ($CASROOT)
@end verbatim

Here we will elect to set environment variables up front.

@verbatim
  setenv CAPRI_ROOT `pwd`/CAPRI
  setenv GEO_SDK `pwd`/SDK/`uname`
  setenv REFINELib `pwd`/refine/`uname`
@end verbatim

The autogen.sh script will create AND run the GNU Autotools configure
script.  Any arguments that might be needed by configure can be given
to autogen.sh (i.e. in lew of using environment variables).  (Ex:
./autogen --with-CAPRI=... instead of setenv CAPRI_ROOT ...)

The SDK is only dependent on CAPRI (no modelers needed) so we will
simply configure with no arguments noting that $CAPRI_ROOT was set
above.

@code{./autogen.sh}

@verbatim
ls

AUTHORS     GeoMap/      Makefile     RacerX/          config.guess*  ltmain.sh
CADGeom/    GeoObjects/  Makefile.Z   UG_API/          config.sub*    missing*
COPYING     Goolache/    Makefile.am  aclocal.m4       configure*
CVS/        GravyLib/    Makefile.in  autogen.sh*      configure.ac
ChangeLog   INSTALL      MeatLib/     autom4te.cache/  depcomp*
Cranberry/  IRIX64/      NEWS         bootstrap*       install-sh*
Fruitcake/  Linux/       README       compile*         libltdl/

cd `uname`
make
make install
[geowulf.larc.nasa.gov Linux]$ ls
CADGeom/    GeoMap/    Makefile  UG_API/     config.status*  libltdl/
Cranberry/  Goolache/  MeatLib/  bin/        include/        libtool*
Fruitcake/  GravyLib/  RacerX/   config.log  lib/            translators/
@end verbatim

Refine will be built against the FELISA Native modeling kernel by
default.  To enable other modelers, either set the environment
variables above or configure with command line arguments that enable
them (configure --help will list the command line args and syntax)

@verbatim
cd ../../refine
./autogen.sh
cd `uname`
make
make install
[geowulf.larc.nasa.gov Linux]$ ls
CVS/      bin/        config.status*  example/     include/  lib/
Makefile  config.log  doc/            geomSGIn32/  info/     src/
@end verbatim

Now for HEFSS

Must set $GEO_SDK and $REFINElib prior to runing HEFSS ./Configure
(see the geowulf host settings for details about building against
refine) 
@verbatim
  cd HEFSS.rps
  make
@end verbatim

@verbatim
cd refine/example
[geowulf.larc.nasa.gov example]$ ls
CVS/               Makefile.in   om6p01.capri   om6ref.m
DebugRunAdapt.rb*  RunAdapt.rb*  om6p01.dat     papmachtop04aniso.lay
FlowConditions.rb  om6mach84.m   om6p01.fastbc  papmachtop06.lay
Makefile.am        om6p01.bac    om6p01.fgrid   propagateLay.rb*

mkdir Flow Adjoint
@end verbatim

edit RunAdapt.rb Change $hefssRoot to the location of your working
copy of HEFSS (i.e.$hefssRoot = ' /scratchZZ:q!/HEFSS.rps').  Other
variables of interest include
@verbatim
    projectRoot  -
    do |n|       - number of adaptation cycles (defaults 1-6)
    numberOfPart - number of partitions
    outputError  - error tolerance
    maxAR        - allowable aspect ratio
    maxEdge      - allowed edge length.
@end verbatim

Edit FlowConditions .rb and make any desired changes as key/value
pairs to replace default ginput.faces file of HEFSS installation.

@code{./RunAdapt.rb}
  You can monitor progress of rad with `tail -F Adjoint/rad_out`
  Output


@node Index
@unnumbered Index

@printindex cp

@bye
